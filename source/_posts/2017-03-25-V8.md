---
layout: post
title: nodejs 的内存泄漏
date: 2017-3-25
categories: [node, v8]
tags: [V8]
description: nodejs 的内存泄漏
---

本文来自Gergely Nemeth的Hunting a Ghost - Finding a Memory Leak in Node.js，其中的术语、代码请以原文为准。


你运行一个node的服务会发现内存使用一直保持在很高的占用，而服务正在一个小型实例上运行，只有512MB的内存。事实证明，应用程序没有泄漏任何内存，只是GC没有开始收集未引用的对象
为什么？默认情况下，nodejs将会使用1.5g左右的内存，当你在有比较小内存的系统上运行时必须对它进行限制。这是我们期望的行为，因为垃圾回收是非常昂贵的操作。
而解决上面的问题只需为Node.js进程添加一个额外的参数：
```sh
node --max_old_space_size=400 server.js —production
```
但是，如果内存泄漏并不是那么明显，你应该以什么样的方式去找到内存泄漏


## 了解V8的内存处理
在深入您可以使用的技术来查找和修复Nodejs应用程序中的内存泄漏之前，让我们来看看V8中如何处理内存

### 定义

* 驻留集大小
	RAM中保存的进程占用的内存部分
	  代码
	  栈
	  堆
* 栈
	原始类型和对象的引用
* 堆
	存储引用类型，如对象，字符串或闭包
* 浅对象的大小
	对象本身内存大小
* 保留对象的大小
	当对象被删除，它的“依赖对象”(引用)释放出来的内存的大小

### GC的工作原理

垃圾回收是回收由应用程序不再使用的对象占用的内存的过程，通常，内存分配的成本是便宜的，而内存池耗尽时收集成本很高
当一个对象从根节点不可访问时，它会成为垃圾收集的候选者，因此不被根对象或任何其他活动对象引用。根对象可以是全局对象，DOM元素或局部变量
堆有两个主要的段，分别为新空间和旧空间。新空间是发生新分配的地方;这里收集垃圾是很快的，大小约为1-8MBs。在新空间的对象叫年青的一代，一些在新空间从收集者那存活下来的对象将被提升到旧空间，他们称这些为老一辈。旧空间中的分配很快，但是收集很昂贵，因此很少执行。
为什么垃圾收集代价是昂贵的？V8 JavaScript引擎采用了 stop-the-world 的垃圾收集机制。在实践中，这意味着程序在垃圾收集进程中停止执行。
通常，约20％的年轻一代幸存下来到老一代。旧空间的垃圾收集只有在空间耗尽之后才会开始。为此，V8引擎使用两种不同的收集算法：
	* 清扫收藏，在青年一代运行的快速的垃圾收算法
	* 标记扫描收集，它比较慢，运行在旧一代


### 总结
V8只有在它需要的时候才进行垃圾回收，即使可能有很多已经取消引用的对象(即当一个对象从根节点不可访问)，它还会保留它们，因为还有足够的内存。当你限制了就空间的大小(默认是1.5g)，v8才会更频繁的收集垃圾从而保持空间大小低于你设置的大小。
当旧空间到达最大值时，node将会抛出异常。例如你尝试将一个超大文件读入缓存区，或者当你在内存里创建了一个超大的数组。这些操作我们应该杜绝
